// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var ReSchemaRegExp = require("./ReSchemaRegExp");
var ReForm__ReSchemaI18n = require("./ReForm__ReSchemaI18n.bs.js");

function Make(Lenses) {
  var $plus = Belt_Array.concat;
  var $less$question = function (arr, maybeArr) {
    if (maybeArr !== undefined) {
      return Belt_Array.concat(arr, [Caml_option.valFromOption(maybeArr)]);
    } else {
      return arr;
    }
  };
  var custom = function (predicate, meta, field) {
    return [{
              TAG: /* Custom */10,
              field: field,
              meta: meta,
              predicate: predicate
            }];
  };
  var true_ = function (error, meta, field) {
    return [{
              TAG: /* True */11,
              field: field,
              error: error,
              meta: meta
            }];
  };
  var false_ = function (error, meta, field) {
    return [{
              TAG: /* False */12,
              field: field,
              error: error,
              meta: meta
            }];
  };
  var email = function (error, meta, field) {
    return [{
              TAG: /* Email */0,
              field: field,
              error: error,
              meta: meta
            }];
  };
  var nonEmpty = function (error, meta, field) {
    return [{
              TAG: /* StringNonEmpty */2,
              field: field,
              error: error,
              meta: meta
            }];
  };
  var string = function (min, minError, max, maxError, meta, field) {
    return $less$question($less$question([], Belt_Option.map(min, (function (min) {
                          return {
                                  TAG: /* StringMin */4,
                                  field: field,
                                  min: min,
                                  error: minError,
                                  meta: meta
                                };
                        }))), Belt_Option.map(max, (function (max) {
                      return {
                              TAG: /* StringMax */5,
                              field: field,
                              max: max,
                              error: maxError,
                              meta: meta
                            };
                    })));
  };
  var regExp = function (error, matches, meta, field) {
    return [{
              TAG: /* StringRegExp */3,
              field: field,
              matches: matches,
              error: error,
              meta: meta
            }];
  };
  var $$float = function (min, minError, max, maxError, meta, field) {
    return $less$question($less$question([], Belt_Option.map(min, (function (min) {
                          return {
                                  TAG: /* FloatMin */8,
                                  field: field,
                                  min: min,
                                  error: minError,
                                  meta: meta
                                };
                        }))), Belt_Option.map(max, (function (max) {
                      return {
                              TAG: /* FloatMax */9,
                              field: field,
                              max: max,
                              error: maxError,
                              meta: meta
                            };
                    })));
  };
  var $$int = function (min, minError, max, maxError, meta, field) {
    return $less$question($less$question([], Belt_Option.map(min, (function (min) {
                          return {
                                  TAG: /* IntMin */6,
                                  field: field,
                                  min: min,
                                  error: minError,
                                  meta: meta
                                };
                        }))), Belt_Option.map(max, (function (max) {
                      return {
                              TAG: /* IntMax */7,
                              field: field,
                              max: max,
                              error: maxError,
                              meta: meta
                            };
                    })));
  };
  var Validation = {
    $plus: $plus,
    $less$question: $less$question,
    custom: custom,
    true_: true_,
    false_: false_,
    email: email,
    nonEmpty: nonEmpty,
    string: string,
    regExp: regExp,
    $$float: $$float,
    $$int: $$int
  };
  var email$1 = ReSchemaRegExp.email;
  var RegExps = {
    email: email$1
  };
  var validateField = function (validator, values, i18n) {
    switch (validator.TAG | 0) {
      case /* Email */0 :
          var field = validator.field;
          var value = Curry._2(Lenses.get, values, field);
          return [
                  /* Field */{
                    _0: field
                  },
                  email$1.test(value) ? /* Valid */0 : ({
                        TAG: /* Error */1,
                        _0: Belt_Option.getWithDefault(validator.error, Curry._1(i18n.email, value))
                      })
                ];
      case /* NoValidation */1 :
          return [
                  /* Field */{
                    _0: validator.field
                  },
                  /* Valid */0
                ];
      case /* StringNonEmpty */2 :
          var field$1 = validator.field;
          var value$1 = Curry._2(Lenses.get, values, field$1);
          return [
                  /* Field */{
                    _0: field$1
                  },
                  value$1 === "" ? ({
                        TAG: /* Error */1,
                        _0: Belt_Option.getWithDefault(validator.error, Curry._1(i18n.stringNonEmpty, value$1))
                      }) : /* Valid */0
                ];
      case /* StringRegExp */3 :
          var matches = validator.matches;
          var field$2 = validator.field;
          var value$2 = Curry._2(Lenses.get, values, field$2);
          return [
                  /* Field */{
                    _0: field$2
                  },
                  new RegExp(matches).test(value$2) ? /* Valid */0 : ({
                        TAG: /* Error */1,
                        _0: Belt_Option.getWithDefault(validator.error, Curry._2(i18n.stringRegExp, value$2, matches))
                      })
                ];
      case /* StringMin */4 :
          var min = validator.min;
          var field$3 = validator.field;
          var value$3 = Curry._2(Lenses.get, values, field$3);
          return [
                  /* Field */{
                    _0: field$3
                  },
                  value$3.length >= min ? /* Valid */0 : ({
                        TAG: /* Error */1,
                        _0: Belt_Option.getWithDefault(validator.error, Curry._2(i18n.stringMin, value$3, min))
                      })
                ];
      case /* StringMax */5 :
          var max = validator.max;
          var field$4 = validator.field;
          var value$4 = Curry._2(Lenses.get, values, field$4);
          return [
                  /* Field */{
                    _0: field$4
                  },
                  value$4.length <= max ? /* Valid */0 : ({
                        TAG: /* Error */1,
                        _0: Belt_Option.getWithDefault(validator.error, Curry._2(i18n.stringMax, value$4, max))
                      })
                ];
      case /* IntMin */6 :
          var min$1 = validator.min;
          var field$5 = validator.field;
          var value$5 = Curry._2(Lenses.get, values, field$5);
          return [
                  /* Field */{
                    _0: field$5
                  },
                  value$5 >= min$1 ? /* Valid */0 : ({
                        TAG: /* Error */1,
                        _0: Belt_Option.getWithDefault(validator.error, Curry._2(i18n.intMin, value$5, min$1))
                      })
                ];
      case /* IntMax */7 :
          var max$1 = validator.max;
          var field$6 = validator.field;
          var value$6 = Curry._2(Lenses.get, values, field$6);
          return [
                  /* Field */{
                    _0: field$6
                  },
                  value$6 <= max$1 ? /* Valid */0 : ({
                        TAG: /* Error */1,
                        _0: Belt_Option.getWithDefault(validator.error, Curry._2(i18n.intMax, value$6, max$1))
                      })
                ];
      case /* FloatMin */8 :
          var min$2 = validator.min;
          var field$7 = validator.field;
          var value$7 = Curry._2(Lenses.get, values, field$7);
          return [
                  /* Field */{
                    _0: field$7
                  },
                  value$7 >= min$2 ? /* Valid */0 : ({
                        TAG: /* Error */1,
                        _0: Belt_Option.getWithDefault(validator.error, Curry._2(i18n.floatMin, value$7, min$2))
                      })
                ];
      case /* FloatMax */9 :
          var max$2 = validator.max;
          var field$8 = validator.field;
          var value$8 = Curry._2(Lenses.get, values, field$8);
          return [
                  /* Field */{
                    _0: field$8
                  },
                  Curry._2(Lenses.get, values, field$8) <= max$2 ? /* Valid */0 : ({
                        TAG: /* Error */1,
                        _0: Belt_Option.getWithDefault(validator.error, Curry._2(i18n.floatMax, value$8, max$2))
                      })
                ];
      case /* Custom */10 :
          return [
                  /* Field */{
                    _0: validator.field
                  },
                  Curry._1(validator.predicate, values)
                ];
      case /* True */11 :
          var field$9 = validator.field;
          var value$9 = Curry._2(Lenses.get, values, field$9);
          return [
                  /* Field */{
                    _0: field$9
                  },
                  value$9 ? /* Valid */0 : ({
                        TAG: /* Error */1,
                        _0: Belt_Option.getWithDefault(validator.error, Curry._1(i18n.true_, undefined))
                      })
                ];
      case /* False */12 :
          var field$10 = validator.field;
          var value$10 = Curry._2(Lenses.get, values, field$10);
          return [
                  /* Field */{
                    _0: field$10
                  },
                  value$10 === false ? /* Valid */0 : ({
                        TAG: /* Error */1,
                        _0: Belt_Option.getWithDefault(validator.error, Curry._1(i18n.false_, undefined))
                      })
                ];
      
    }
  };
  var getFieldValidator = function (validators, fieldName) {
    return Belt_Array.getBy(validators, (function (validator) {
                  return Caml_obj.caml_equal(/* Field */{
                              _0: validator.field
                            }, fieldName);
                }));
  };
  var getFieldValidators = function (validators, fieldName) {
    return Belt_Array.keep(validators, (function (validator) {
                  return Caml_obj.caml_equal(/* Field */{
                              _0: validator.field
                            }, fieldName);
                }));
  };
  var validateOne = function (field, values, i18n, schema) {
    return Belt_Array.getBy(Belt_Array.map(getFieldValidators(schema._0, field), (function (validator) {
                      return validateField(validator, values, i18n);
                    })), (function (validation) {
                  var tmp = validation[1];
                  if (typeof tmp === "number" || tmp.TAG === /* NestedErrors */0) {
                    return false;
                  } else {
                    return true;
                  }
                }));
  };
  var validateFields = function (fields, values, i18n, schema) {
    var validators = schema._0;
    return Belt_Array.map(fields, (function (field) {
                  return Belt_Option.map(getFieldValidator(validators, field), (function (validator) {
                                return validateField(validator, values, i18n);
                              }));
                }));
  };
  var validate = function (i18nOpt, values, schema) {
    var i18n = i18nOpt !== undefined ? i18nOpt : ReForm__ReSchemaI18n.$$default;
    var validationList = Belt_Array.map(schema._0, (function (validator) {
            return validateField(validator, values, i18n);
          }));
    var errors = Belt_Array.keepMap(validationList, (function (param) {
            var fieldState = param[1];
            if (typeof fieldState === "number" || fieldState.TAG === /* NestedErrors */0) {
              return ;
            } else {
              return [
                      param[0],
                      fieldState._0
                    ];
            }
          }));
    if (errors.length !== 0) {
      return /* Errors */{
              _0: errors
            };
    } else {
      return /* Valid */0;
    }
  };
  return {
          Validation: Validation,
          RegExps: RegExps,
          validateField: validateField,
          getFieldValidator: getFieldValidator,
          getFieldValidators: getFieldValidators,
          validateOne: validateOne,
          validateFields: validateFields,
          validate: validate
        };
}

exports.Make = Make;
/* ./ReSchemaRegExp Not a pure module */
